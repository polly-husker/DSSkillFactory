
 Соревнование на Kaggle https://www.kaggle.com/c/sf-dl-car-classification/overview

Классификация изображений авто - построением модели НС на основании существующий, с использованием подхода  Transfer Learning и fine tuning

Ссылка на лог выполнения 
https://www.kaggle.com/polinaseliukh/polina-s-fork-keras-xception-car-class-v2-0

Выводы

Сразу со сложностей - столкнулась со сложностями, так как превышала лимит в 30 часов в неделю. Осталось для меня не выяснено как в датасете 1-model, куда я вручную переносила файлы моделей от итерации к итерации (ограничение на 8 или 9 часов работы сессии GPU) - как в датасете ходить от версии к версии.

По работе:

были эксперименты, где модель начиналась с базовой Efficient Net B5 (efnb5) и обучалась целиком - где-то на 80 эпoхах обучение закончилось по earlystop (patience=20) и точность модели была 81% - по времени ушло почти 8 часов

были эксперименты, с efnb5 и xception - где базовые модели замораживались на обучении - efn давало точность выше на процентов 7-8 - тут было мало эпох, порядка 20. Было принято решение дальше экспереминтировать только с efn

efn как базовая модель замораживалась, и потом было 3 этапа fine-tuning - доли размораживающихся слоев выбирались исходя из мысли - постепенно увеличивать количество обучаемых параметров модели. Для EFN подобрала сначала разморозить 1/8 часть на обучение, потом 1/4, потом все слои. Понравился такой вариант тем, что он по времени показался более эффективным. Возможно так "сильно" уменьшать LR от итерации fine-tuninga к следующей не стоит, но времени GPU пока нет, чтоб это проверить. Без GPU беспощадно долго считать (на 5 эпох уходило порядка 9-10 часов О_о)

Из досадного - влетала в ходе экспериментов на превышение объемов памяти, уменьшала размер batch-ей, но время GPU было уже не вернуть, так как эксперименты ставились на ночь. Любопытно - нет ли каких-то вариантов предвидеть такие вещи, как-то просчитать - не понимаю от каких параметров и хоть примерно как (линейно, квадратично или еще как ) зависит объем памяти, который нужен будет во время вычислений (в своих "привычных" задачах из криптографии пользуюсь таким предварительным анализом - а тут не знаю как)